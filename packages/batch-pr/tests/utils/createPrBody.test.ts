import { type BatchIssueType, createPrBody } from '../../utils/createPrBody';

import { describe, expect, test } from 'vitest';

describe('createPrBody', () => {
  describe('when given empty issue status array', () => {
    test('should return PR body with empty resolved issues section', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('## ❄️ Batch Pull Request');
      expect(result).toContain('### Resolved Issues');
      expect(result).toContain('**DO NOT EDIT THIS PR MANUALLY**');
      expect(result).toContain(
        'This PR is automatically managed by the Batch PR plugin',
      );
      expect(result).toContain('Generated by [Yuki-no Batch PR Plugin]');

      // Should have empty resolved issues section
      const resolvedSection = result
        .split('### Resolved Issues')[1]
        .split('---')[0];
      expect(resolvedSection.trim()).toBe('');
    });
  });

  describe('when given single issue', () => {
    test('should return PR body with single resolved issue', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 42, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('Resolved #42');
      expect(result).toContain('## ❄️ Batch Pull Request');
      expect(result).toContain('### Resolved Issues');

      // Should contain exactly one issue reference
      const resolvedMatches = result.match(/Resolved #\d+/g);
      expect(resolvedMatches).toHaveLength(1);
      expect(resolvedMatches?.[0]).toBe('Resolved #42');
    });
  });

  describe('when given multiple issues', () => {
    test('should return PR body with all resolved issues listed', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 10, type: 'Resolved' },
        { number: 25, type: 'Resolved' },
        { number: 100, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('Resolved #10');
      expect(result).toContain('Resolved #25');
      expect(result).toContain('Resolved #100');

      // Should contain exactly three issue references
      const resolvedMatches = result.match(/Resolved #\d+/g);
      expect(resolvedMatches).toHaveLength(3);

      // Should maintain order
      const resolvedSection = result
        .split('### Resolved Issues')[1]
        .split('---')[0];
      expect(resolvedSection.indexOf('Resolved #10')).toBeLessThan(
        resolvedSection.indexOf('Resolved #25'),
      );
      expect(resolvedSection.indexOf('Resolved #25')).toBeLessThan(
        resolvedSection.indexOf('Resolved #100'),
      );
    });
  });

  describe('PR body structure validation', () => {
    test('should contain all required sections in correct order', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 123, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      // Check for caution section
      expect(result).toContain('> [!CAUTION]');
      expect(result).toContain('> **DO NOT EDIT THIS PR MANUALLY**');
      expect(result).toContain(
        '> This PR is automatically managed by the Batch PR plugin. Manual changes will be overwritten.',
      );

      // Check for main title
      expect(result).toContain('## ❄️ Batch Pull Request');

      // Check for description
      expect(result).toContain(
        'This PR collects opened Yuki-no translation issues into a single pull request.',
      );

      // Check for resolved issues section
      expect(result).toContain('### Resolved Issues');

      // Check for footer
      expect(result).toContain('---');
      expect(result).toContain(
        '*Generated by [Yuki-no Batch PR Plugin](https://github.com/Gumball12/yuki-no/tree/main/packages/batch-pr/)*',
      );
    });

    test('should have proper markdown formatting', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 456, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      // Should start with newline
      expect(result.startsWith('\n')).toBe(true);

      // Should end with newline
      expect(result.endsWith('\n')).toBe(true);

      // Should contain proper heading levels
      expect(result).toMatch(/^## ❄️ Batch Pull Request$/m);
      expect(result).toMatch(/^### Resolved Issues$/m);

      // Should contain proper link syntax
      expect(result).toContain(
        '[Yuki-no Batch PR Plugin](https://github.com/Gumball12/yuki-no/tree/main/packages/batch-pr/)',
      );
    });
  });

  describe('issue comment formatting', () => {
    test('should format single issue comment correctly', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 789, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('Resolved #789');

      // Should be on its own line in the resolved section
      const resolvedSection = result
        .split('### Resolved Issues')[1]
        .split('---')[0];
      expect(resolvedSection).toContain('\nResolved #789\n');
    });

    test('should format multiple issue comments correctly', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 1, type: 'Resolved' },
        { number: 999, type: 'Resolved' },
        { number: 42, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      const resolvedSection = result
        .split('### Resolved Issues')[1]
        .split('---')[0];

      // Each issue should be on its own line
      expect(resolvedSection).toContain('\nResolved #1\n');
      expect(resolvedSection).toContain('\nResolved #999\n');
      expect(resolvedSection).toContain('\nResolved #42\n');

      // Should maintain the provided order
      const issue1Index = resolvedSection.indexOf('Resolved #1');
      const issue999Index = resolvedSection.indexOf('Resolved #999');
      const issue42Index = resolvedSection.indexOf('Resolved #42');

      expect(issue1Index).toBeLessThan(issue999Index);
      expect(issue999Index).toBeLessThan(issue42Index);
    });
  });

  describe('edge cases', () => {
    test('should handle large issue numbers correctly', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 999999, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('Resolved #999999');
    });

    test('should handle single digit issue numbers correctly', () => {
      // Given
      const issueStatus: Array<{ number: number; type: BatchIssueType }> = [
        { number: 1, type: 'Resolved' },
      ];

      // When
      const result = createPrBody(issueStatus);

      // Then
      expect(result).toContain('Resolved #1');
    });

    test('should maintain consistent structure regardless of input size', () => {
      // Given
      const emptyIssueStatus: Array<{ number: number; type: BatchIssueType }> =
        [];
      const singleIssueStatus: Array<{ number: number; type: BatchIssueType }> =
        [{ number: 1, type: 'Resolved' }];
      const multipleIssueStatus: Array<{
        number: number;
        type: BatchIssueType;
      }> = [
        { number: 1, type: 'Resolved' },
        { number: 2, type: 'Resolved' },
        { number: 3, type: 'Resolved' },
      ];

      // When
      const emptyResult = createPrBody(emptyIssueStatus);
      const singleResult = createPrBody(singleIssueStatus);
      const multipleResult = createPrBody(multipleIssueStatus);

      // Then
      // All should have the same structural elements
      const structuralElements = [
        '> [!CAUTION]',
        '## ❄️ Batch Pull Request',
        'This PR collects opened Yuki-no translation issues',
        '### Resolved Issues',
        '---',
        '*Generated by [Yuki-no Batch PR Plugin]',
      ];

      structuralElements.forEach(element => {
        expect(emptyResult).toContain(element);
        expect(singleResult).toContain(element);
        expect(multipleResult).toContain(element);
      });
    });
  });
});
